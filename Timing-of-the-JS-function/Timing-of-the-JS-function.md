# JS函数的调用时机
在JavaScript中的函数，存在一个调用时机的问题，为了更好的说明这个问题，下面举几个例子来更好的说明。    

```javascript
let a = 1
function fn(){
    console.log(a)
}
fn()
//请问此时会打印出多少？
```  

很显然，答案是1。那么再看看下面这个例子：    

```javascript
let a = 1
function fn(){
    console.log(a)
}

a=2
fn()
//请问此时会打印出多少
```  

答案是2，答案也很明显，之前的全局变量a=1被之后的a=2给赋值了，所以在引用fn时，此时的a=2。  
再看这一个例子：    

```javascript
let a = 1
function fn(){
    console.log(a)
}

fn()
a=2
问此时会打印出多少？
```  

答案是1，那后面的a=2是来干嘛的？那是来迷惑你的，可见调用函数是存在着一个时机的。那么再看看下面的例子：  

```javascript
let a = 1
function fn(){
    setTimeout(()=>{console.log(a)},0)
}

fn()
a=2
问此时会打印出多少？
```  


答案是2，为什么？这里先不提setTimeout的属性，大概把他理解成过一段时间再执行，就像是一个具有倒计时功能的东西，过了一段时间后才会执行fn函数，那么一段时间后，此时的进程已经来到了a=2了，a=1已经被覆盖了，那么这时候打印出的a的值，就是2。  
那么就有一个升级版：   

```javascript
let i = 0
for(i = 0; i<6; i++){
setTimeout(()=>{console.log(i)},0)
}

此时会打印出什么
```  

大多数初见者会认为是打印出0,1,2,3,4,5,而正确答案是**6个6**，是不是很神奇。为什么会这样？这也是同我上面所说，过一段时间再执行setTimeout，那么这里的循环，在他过一段时间时，并不会停止循环，而是会继续执行i++的指令，直到i=6停止了循环，之后才打印出了6。这里也可以理解为setTimeout是一个支线任务，而要完成支线任务必须要完成for循环这个主线任务，那么到for循环这个主线任务完成后，一切的东西都改变了，但是这个支线任务还是要在主线任务完成后再进行6次一样的指令。那么此时主线任务循环已经结束，i已经等于了6，所以打印出的数字自然是6，因此会打印出6个6。  
但是仍然有很多人不能理解这个，所以在新版的JS做了改善，只需要在for循环中用let声明，就可以打印出大众所认知的0,1,2,3,4,5了。    

```javascript
for(let i = 0; i<6; i++){
setTimeout(()=>{console.log(i)},0)
}
```  

是不是很神奇，也不懂这样修改是好还是不好呢？  
那么到底还有什么办法能不用for循环，就能打印出0,1,2,3,4,5呢？？
